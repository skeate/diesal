<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/ds/BinarySearchTree.js | diesal</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Data structures and algorithms in ES2015 modules"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="diesal"><meta property="twitter:description" content="Data structures and algorithms in ES2015 modules"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a href="http://github.com/skeate/diesal">Repository</a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#ds">ds</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ds/BinarySearchTree.js~BinarySearchTree.html">BinarySearchTree</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ds/Heap.js~Heap.html">Heap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ds/IntervalTree.js~IntervalTree.html">IntervalTree</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/ds/BinarySearchTree.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * A single node in the tree. Provides some useful computed properties.
 *
 * @property {*} value The value of the node
 * @property {?Node} parent The parent of the node
 * @property {?Node} left The left child of the node
 * @property {?Node} right The right child of the node
 */
class Node {
  /**
   * Create a node.
   *
   * @param {*} value The value of the node
   * @param {?Node} parent The parent of the node
   */
  constructor(value, parent = null) {
    this.value = value;
    this.parent = parent;
    this.left = null;
    this.right = null;
  }

  /**
   * The node that contains the lowest value in this node&apos;s subtree.
   *
   * @returns {Node}
   */
  get leftmostDescendant() {
    return this.left ? this.left.leftmostDescendant : this;
  }

  /**
   * The node that contains the highest value in this node&apos;s subtree.
   *
   * @returns {Node}
   */
  get rightmostDescendant() {
    return this.right ? this.right.rightmostDescendant : this;
  }
}

/**
 * A binary search tree is a container where each value is stored in a node, and
 * each node has two children: a left and a right. Values less than the value of
 * the node are put in the left child, and values greater than it are put in the
 * right child. In general, this results in O(log n) search, insertion, and
 * deletion, for only O(n) space.
 */
export default class BinarySearchTree {
  /**
   * @param {Array} [list] A list of initial values to insert into the tree.
   * @param {Function} [cmp] A comparison function taking two arguments and
   * returning a boolean. Defaults to `(a, b) =&gt; a &lt; b`
   */
  constructor(list = [], cmp = (a, b) =&gt; a &lt; b) {
    this._root = null;
    this._cmp = cmp;
    /**
     * @type {number}
     */
    this.length = 0;
    list.forEach(item =&gt; this.insert(item));
  }

  _insert(value, parent = this._root) {
    // Our tree has no nodes, so regardless of the value, it must be the _root.
    if (!this._root) {
      this._root = new Node(value);
      return ++this.length;
    }
    // Compare the value to the current parent&apos;s value. If it is lower, then it
    // should go on the left side.
    if (this._cmp(value, parent.value)) {
      // If the parent node doesn&apos;t have a left child, then we should put the
      // value there.
      if (parent.left === null) {
        parent.left = new Node(value, parent);
        return ++this.length;
      }
      // Otherwise, recurse, with the left value as the new parent.
      return this._insert(value, parent.left);
    } else if (parent.right === null) {
      // If it is greater than or equal to the value, then it should go on the
      // right side. Code is the same, but switch any &apos;left&apos; with &apos;right&apos;.
      parent.right = new Node(value, parent);
      return ++this.length;
    }
    return this._insert(value, parent.right);
  }

  /**
   * Inserts a value into the tree.
   *
   * @param {*} value The value to insert
   * @returns {number} The new size of the tree
   */
  insert(value) {
    return this._insert(value);
  }

  /**
   * Search for a value in the tree.
   *
   * @private
   * @param {*} value Value for which to search
   * @param {Node} node The current search _root
   * @return {?Node} null if not found, otherwise the node
   */
  _search(value, node = this._root) {
    // There are four possibilities:
    // 1. `node` is `null`: The value we&apos;re looking for isn&apos;t in the tree.
    // 2. `node.value` is `value`: We&apos;ve found the value.
    // In both of these cases, we can simply return `node` -- in case 1, this
    // means it returns `null`, which is what we want if the value doesn&apos;t exist
    // in the tree.
    if (!node || node.value === value) {
      return node;
    }
    // 3. `value` is less than `node.value`: Search again, this time looking at
    //    only the values that are less than `node.value` (by looking at its
    //    left subtree)
    if (this._cmp(value, node.value)) {
      return this._search(value, node.left);
    }
    // 4. `value` is greater than `node.value`: Search again, this time looking
    //    at only the values that are greater than `node.value` (by looking at
    //    its right subtree)
    return this._search(value, node.right);
  }

  /**
   * Checks if the given value is in the tree.
   *
   * @param {*} value The value to check for
   * @returns {boolean} Whether or not the value is in the collection
   */
  contains(value) {
    return Boolean(this._search(value));
  }

  /**
   * Removes a value from the tree. If the value is in the tree multiple times,
   * it will remove the first one found.
   *
   * @param {*} value The value to remove.
   * @return {?number} The new length of the array (or null if no matching node
   * found)
   */
  remove(value) {
    // First, find the node.
    const node = this._search(value);
    // If it doesn&apos;t exist in the tree, we can exit.
    if (!node) {
      return null;
    }
    let _rootParent = null;
    if (node === this._root) {
      node.parent = { left: this._root };
      _rootParent = node.parent;
    }
    // If it has both left and right children, we need to do some extra work.
    // Find the next higher value (the right subtree&apos;s leftmost descendant),
    // swap out the values, and remove the other node.
    if (node.left &amp;&amp; node.right) {
      const nextHigher = node.right.leftmostDescendant;
      node.value = nextHigher.value;
      // If the nextHigher node is the right child of its parent, replace it
      // with its own right children (if any). This can only happen if we had
      // a chain of only right children (or the node we&apos;re deleting only had one
      // right descendant)
      const nodeSide = nextHigher.parent.left === nextHigher ? &apos;left&apos; : &apos;right&apos;;
      nextHigher.parent[nodeSide] = nextHigher.right;
      // Don&apos;t forget to reset parents
      if (nextHigher.right) {
        nextHigher.right.parent = nextHigher.parent;
      }
    } else {
      // If it only has one child, then we just replace it with its own child.
      // If it has no children, we can just remove it. This condition is rolled
      // into the final else, since with no children, `node.right` is `null`.
      const nodeSide = node.parent.left === node ? &apos;left&apos; : &apos;right&apos;;
      if (node.left) {
        node.parent[nodeSide] = node.left;
        // Don&apos;t forget to reset parents
        node.left.parent = node.parent;
      } else {
        node.parent[nodeSide] = node.right;
        // Don&apos;t forget to reset parents
        if (node.right) {
          node.right.parent = node.parent;
        }
      }
    }
    if (_rootParent) {
      this._root = _rootParent.left;
    }
    return --this.length;
  }

  _toArray(node = this._root) {
    // An in-order traversal should (as you might expect) traverse the nodes in
    // value order. Since the tree is sorted so that smaller values go to the
    // left subtree, and larger values go to the right subtree, we want to visit
    // the left tree first, then include the current node itself, then all the
    // right subtree.
    let arr = [];
    if (node) {
      if (node.left) {
        arr = arr.concat(this._toArray(node.left));
      }
      arr = arr.concat(node.value);
      if (node.right) {
        arr = arr.concat(this._toArray(node.right));
      }
    }
    return arr;
  }

  /**
   * Converts the tree into an array using an in-order traversal of the tree.
   *
   * @returns {Array} The contents of the tree as a sorted array
   */
  toArray() {
    return this._toArray();
  }

  /**
   * Finds the immediate predecessor of the given value
   *
   * @param {*} value The value to find the predecessor for
   * @returns {*} Predecessor value, or null if value not found or min
   */
  getPredecessor(value) {
    return this._getNeighbor(value, true);
  }

  /**
   * Finds the immediate successor of the given value
   *
   * @param {*} value The value to find the successor for
   * @returns {*} Successor value, or null if value not found or max
   */
  getSuccessor(value) {
    return this._getNeighbor(value, false);
  }

  /**
   * Finds the immediate predecessor or successor of the given value
   *
   * @private
   * @param {*} value The value to find the predecessor or successor for
   * @param {boolean} findPredecessor Whether to find predecessor (true) or
   * successor (false)
   * @returns {*} The predecessor or successor
   */
  _getNeighbor(value, findPredecessor) {
    let foundNode = this._search(value);
    if (!foundNode) {
      return null;
    }
    let sideToCheck;
    let descendant;
    if (findPredecessor) {
      sideToCheck = &apos;left&apos;;
      descendant = &apos;rightmostDescendant&apos;;
    } else {
      sideToCheck = &apos;right&apos;;
      descendant = &apos;leftmostDescendant&apos;;
    }
    if (foundNode[sideToCheck]) {
      return foundNode[sideToCheck][descendant].value;
    }
    while (foundNode.parent &amp;&amp; foundNode.parent[sideToCheck] === foundNode) {
      foundNode = foundNode.parent;
    }
    if (!foundNode.parent) {
      return null;
    }
    return foundNode.parent.value;
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.1)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
