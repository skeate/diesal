<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/ds/Heap.js | diesal</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Data structures and algorithms in ES2015 modules"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="diesal"><meta property="twitter:description" content="Data structures and algorithms in ES2015 modules"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a href="http://github.com/skeate/diesal">Repository</a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#ds">ds</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ds/BinarySearchTree.js~BinarySearchTree.html">BinarySearchTree</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ds/Heap.js~Heap.html">Heap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ds/IntervalTree.js~IntervalTree.html">IntervalTree</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/ds/Heap.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * Gets the index of the parent of the given index in the heap-array.
 *
 * @private
 * @param {number} index  The index of the child of which to find the parent.
 * @returns {number} the parent index
 */
function getParent(index) {
  return Math.floor((index - 1) / 2);
}

/**
 * Gets the indexes of the children of the node at the given index.
 *
 * @private
 * @param {number} index  The index of the parent of which to find the
 * children.
 * @returns {number[]} an array of the children indexes
 */
function getChildren(index) {
  return [2 * index + 1, 2 * index + 2];
}

/**
 * A Heap is a data structure that satisfies the *heap property*: if A is
 * a parent node of B, then the value of node A is ordered with respect to the
 * value of B, with the same ordering applying across all nodes. Heaps are an
 * implementation of a Priority Queue, providing fast (O(1)) access to the min,
 * and reasonable (O(logn) or better, depending on variant) performance for
 * insert and delete.
 *
 * This particular implementation is of a binary heap, where each node has 0-2
 * children.
 *
 * For more information:
 *
 * [Heaps][Heap]
 *
 * [Binary Heaps][BinHeap]
 *
 * Note that in all descriptions, where we use &quot;min&quot;, it really depends on what
 * your comparison function is. The default is a min function.
 *
 * [Heap]: https://en.wikipedia.org/wiki/Heap_(data_structure)
 * [BinHeap]: https://en.wikipedia.org/wiki/Binary_heap
 */
export default class Heap {
  /**
   * Create a Heap.
   *
   * @param {*[]} [list] A list of initial entries into the heap
   * @param {Function} [cmp] A function to compare elements in the heap
   */
  constructor(list = [], cmp = (a, b) =&gt; a &lt; b) {
    this._cmp = cmp;
    this._heap = list;
    for (let i = Math.floor(this._heap.length / 2) - 1; i &gt;= 0; i--) {
      this._heapify(i);
    }
  }

  /**
   * The number of elements in the heap
   *
   * @type {number}
   */
  get size() {
    return this._heap.length;
  }

  /**
   * Insert a new element into the heap, maintaining the heap property.
   *
   * @param {*} value The value to insert
   * @returns {number} The new size of the heap
   */
  push(value) {
    let index = this._heap.push(value) - 1;
    let check = true;
    while (check) {
      const parent = getParent(index);
      if (parent &gt;= 0 &amp;&amp; this._cmp(value, this._heap[parent])) {
        this._swap(index, parent);
        index = parent;
      } else {
        check = false;
      }
    }
    return this.size;
  }

  /**
   * Gets the min value and removes it from the heap, adjusting everything else
   * in the heap to maintain heap property, then returns the value.
   *
   * @returns {*} The min value in the heap.
   */
  pop() {
    // remove and store lowest value
    const min = this._heap.shift();
    if (typeof min === &apos;undefined&apos;) {
      return null;
    }
    if (this._heap.length) {
      // put the last element into the root position
      this._heap.unshift(this._heap.pop());
      this._heapify();
    }
    return min;
  }

  /**
   * Checks if the value is inside the collection
   *
   * @param {*} value The value to find
   * @returns {boolean} Whether or not the value was found in the collection
   */
  contains(value) {
    return this._heap.indexOf(value) &gt;= 0;
  }

  /**
   * Iteratively goes through tree, ensuring heap property is maintained,
   * correcting it if not.
   *
   * @private
   * @param {number} i The index of what should be the largest node of a subtree
   */
  _heapify(i = 0) {
    // if this breaks the heap property, fix it. rinse and repeat until heap
    // property is true.
    const len = this._heap.length;
    let largest = i;
    getChildren(i).forEach((child) =&gt; {
      if (child &lt; len &amp;&amp; this._cmp(this._heap[child], this._heap[largest])) {
        largest = child;
      }
    });
    if (largest !== i) {
      this._swap(largest, i);
      this._heapify(largest);
    }
  }

  /**
   * Swaps two indexes in the heap.
   *
   * @private
   * @param {number} a First element to swap
   * @param {number} b Second element to swap
   */
  _swap(a, b) {
    [this._heap[a], this._heap[b]] = [this._heap[b], this._heap[a]];
  }
  /**
   * Gets the min value of the heap (if your cmp function is a less-than
   * comparison).
   *
   * @returns {*} The min value
   */
  findMin() {
    return this._heap[0];
  }

  /**
   * Gets the max value of the heap (if your cmp function is a greater-than
   * comparison). (Functionally, identical to findMin -- included for semantic
   * reasons based on comparison function)
   *
   * @returns {*} The max value
   */
  findMax() {
    return this._heap[0];
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.1)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
